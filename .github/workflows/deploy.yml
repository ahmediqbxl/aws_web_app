name: Build, Test, and Deploy

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security and dependency scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Lint and test
  test:
    name: Test Application
    runs-on: ubuntu-latest
    needs: security-scan
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd application
          npm ci

      - name: Run linting
        run: |
          cd application
          npm run lint

      - name: Run tests
        run: |
          cd application
          npm test

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./application/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # Build and push Docker image
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./application
          file: ./application/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to AWS
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ca-central-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        run: |
          cd infrastructure
          terraform init

      - name: Terraform Plan
        run: |
          cd infrastructure
          terraform plan -var="environment=${{ github.event.inputs.environment || 'dev' }}"

      - name: Terraform Apply
        run: |
          cd infrastructure
          terraform apply -auto-approve -var="environment=${{ github.event.inputs.environment || 'dev' }}"
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}

      - name: Get deployment outputs
        id: terraform_outputs
        run: |
          cd infrastructure
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
          echo "asg_name=$(terraform output -raw asg_name)" >> $GITHUB_OUTPUT

      - name: Wait for instances to be ready
        run: |
          echo "Waiting for Auto Scaling Group to reach desired capacity..."
          aws autoscaling wait group-in-service \
            --auto-scaling-group-name ${{ steps.terraform_outputs.outputs.asg_name }} \
            --region ca-central-1

      - name: Deploy application to instances
        run: |
          # Get instance IDs from Auto Scaling Group
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ steps.terraform_outputs.outputs.asg_name }} \
            --region ca-central-1 \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          echo "Found instances: $INSTANCE_IDS"
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"
            
            # Use AWS Systems Manager to run commands on instances
            aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["cd /opt/aws_web_app && ./deploy.sh"]' \
              --region ca-central-1
            
            # Wait for command to complete
            sleep 30
          done

      - name: Health check
        run: |
          ALB_DNS=${{ steps.terraform_outputs.outputs.alb_dns_name }}
          
          echo "Performing health check on: http://$ALB_DNS/health"
          
          # Wait for load balancer to be ready
          sleep 60
          
          # Perform health check
          for i in {1..10}; do
            if curl -f "http://$ALB_DNS/health"; then
              echo "✅ Health check passed!"
              break
            else
              echo "⏳ Health check attempt $i failed, retrying in 30 seconds..."
              sleep 30
            fi
          done

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "🚀 Deployment successful!"
            echo "Application URL: http://${{ steps.terraform_outputs.outputs.alb_dns_name }}"
            echo "Health Check: http://${{ steps.terraform_outputs.outputs.alb_dns_name }}/health"
            echo "Metrics: http://${{ steps.terraform_outputs.outputs.alb_dns_name }}/metrics"
          else
            echo "❌ Deployment failed!"
            exit 1
          fi

  # Integration tests
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ca-central-1

      - name: Get ALB DNS name
        id: get_alb
        run: |
          cd infrastructure
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: Wait for application to be ready
        run: |
          ALB_DNS=${{ steps.get_alb.outputs.alb_dns_name }}
          echo "Waiting for application to be ready..."
          sleep 120

      - name: Run integration tests
        run: |
          ALB_DNS=${{ steps.get_alb.outputs.alb_dns_name }}
          
          echo "Running integration tests against: http://$ALB_DNS"
          
          # Test main endpoint
          curl -f "http://$ALB_DNS/" || exit 1
          
          # Test health endpoint
          curl -f "http://$ALB_DNS/health" || exit 1
          
          # Test metrics endpoint
          curl -f "http://$ALB_DNS/metrics" || exit 1
          
          # Test API endpoint
          curl -f "http://$ALB_DNS/api/status" || exit 1
          
          echo "✅ All integration tests passed!"

  # Performance testing
  performance-test:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ca-central-1

      - name: Get ALB DNS name
        id: get_alb
        run: |
          cd infrastructure
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: Install Apache Bench
        run: sudo apt-get update && sudo apt-get install -y apache2-utils

      - name: Run performance tests
        run: |
          ALB_DNS=${{ steps.get_alb.outputs.alb_dns_name }}
          
          echo "Running performance tests against: http://$ALB_DNS"
          
          # Test homepage performance
          echo "Testing homepage performance..."
          ab -n 100 -c 10 "http://$ALB_DNS/"
          
          # Test health endpoint performance
          echo "Testing health endpoint performance..."
          ab -n 100 -c 10 "http://$ALB_DNS/health"
          
          echo "✅ Performance tests completed!"

  # Cleanup (optional)
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deploy, integration-test, performance-test]
    if: always() && github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ca-central-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Destroy (Dev Environment Only)
        if: github.event.inputs.environment == 'dev'
        run: |
          cd infrastructure
          terraform init
          terraform destroy -auto-approve -var="environment=dev"
        env:
          TF_VAR_environment: dev

      - name: Notify cleanup completion
        run: |
          if [ "${{ github.event.inputs.environment }}" == "dev" ]; then
            echo "🧹 Dev environment cleanup completed!"
          else
            echo "ℹ️  Cleanup skipped for non-dev environment"
          fi 